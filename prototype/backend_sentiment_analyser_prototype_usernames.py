# -*- coding: utf-8 -*-
"""backend_sentiment_analyser_prototype_usernames.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gD4JqVBNlB0Kn3d1JjlmVtVwbIBvusav
"""

import nltk
from nltk import corpus
from afinn import Afinn

def hello_world(request):
    """Responds to any HTTP request.
    Args:
        request (flask.Request): HTTP request object.
    Returns:
        The response text or any set of values that can be turned into a
        Response object using
        `make_response <http://flask.pocoo.org/docs/1.0/api/#flask.Flask.make_response>`.
    """

    if request.method == 'OPTIONS':
    # Allows GET requests from any origin with the Content-Type
    # header and caches preflight response for an 3600s
      headers = {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET',
          'Access-Control-Allow-Headers': 'Content-Type',
          'Access-Control-Max-Age': '3600'
      }

      return ('', 204, headers)

    english_words = nltk.download('words')
    english_vocab = set(word.lower() for word in nltk.corpus.words.words())

    #getting user input
    name = request.args.get('name')

    #formatting as string to handle errors
    name = str(name)
    #afinn only accepts lower case values
    name = name.lower()

    #finding set intersection with nltk dictionary
    all_possible_words = {name[i:j + i] for j in range(2, len(name)) for i in range(len(name)- j + 1)}
    all_words = english_vocab.intersection(all_possible_words)
    all_words = list(set(list(all_words)))

    #instantiating model
    afinn = Afinn(emoticons=True)

        # Set CORS headers for the main request
    headers = {
        'Access-Control-Allow-Origin': '*'
    }
    
    #get max valence polarty score in username to extract nominal realism
    try:
        output = max([afinn.score(word) for word in all_words], key=abs)
        output_name = afinn.score(name)

        #handling nominal realism in mononymous names
        #e.g. 'blind'
        
        if output_name > output:
            output = output_name
        
        #return out outputs od names
        
        if output > 0:
            return ('positive', 200, headers)

        elif output < 0:
            return ('negative', 200, headers)
        
        else:
            return ('neutral', 200, headers)
            
        #return neutral if error
    except:
        return ('neutral', 200, headers)